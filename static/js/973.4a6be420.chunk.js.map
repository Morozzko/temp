{"version":3,"file":"static/js/973.4a6be420.chunk.js","mappings":"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","sources":["constants/index.ts","constants/app/index.ts","features/services/logs/constants/name.ts","features/services/logs/structure/index.ts","features/services/logs/store/index.ts","features/services/logs/constants/constants.ts","features/services/timers/constants/name.ts","features/services/timers/structure/index.ts","features/services/timers/constants/constants.ts","features/services/timers/store/index.ts","features/services/timers/index.tsx","features/services/timers/container/index.ts","app/store/reducers.ts","app/store/store.ts","app/providers/ReduxStoreProvider/index.tsx","app/providers/index.tsx","components/templates/404/index.tsx","components/templates/Loading/index.tsx","layouts/index.tsx","layouts/Main/index.tsx","app/router/index.tsx","app/entry/ui/index.tsx","app/entry/index.tsx","app/entry/container/index.tsx","index.tsx","serviceWorkerRegistration.ts","reportWebVitals.ts","utils/hooks/useAppActions.ts","utils/hooks/useAppSelector.ts"],"sourcesContent":["import { app } from './app'\n\n// Здесь хранятся константы приложения, которые могут быть использованы в разных частях приложения.\nexport const Constants = {\n  app,\n}\n","import json from '../../../package.json'\n\nexport const app = {\n  name: json?.name,\n}\n","import { Constants } from '@constants/index'\n\nexport const name = `[@${Constants.app.name} - logs - Service]`\n","import { LogType } from '../lib/types'\n\nexport const initialState = {\n  logs: [] as LogType[],\n}\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { maxLogsCount } from '../constants/constants'\nimport { name } from '../constants/name'\nimport { initialState } from '../structure'\n\nexport const slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    addLog(state, action: PayloadAction<string>) {\n      const date = new Date()\n      const dateToString = `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}.${date.getMilliseconds()}`\n      state.logs.push({\n        date: dateToString,\n        text: action.payload,\n      })\n\n      // Чтобы не раздуть лог\n      if (state.logs.length >= maxLogsCount) {\n        state.logs.shift()\n      }\n    },\n    reset: () => initialState,\n  },\n})\n\nexport const Actions = {\n  ...slice.actions,\n}\n\nexport const Reducer = slice.reducer\n","export const maxLogsCount = 1000\n","import { Constants } from '@constants/index'\n\nexport const name = `[@${Constants.app.name} - timers - Service]`\n","import { defaultTimersCount } from '../constants/constants'\n\nexport const initialState = {\n  timersCount: defaultTimersCount,\n  timersQueue: [] as number[],\n}\n","export const defaultTimersCount = 4\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { name } from '../constants/name'\nimport { initialState } from '../structure'\n\nexport const slice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    addTimerToQueue(state, action: PayloadAction<number>) {\n      state.timersQueue.push(action.payload)\n    },\n\n    removeTimerFromQueue(state) {\n      state.timersQueue.shift()\n    },\n\n    addTimer(state) {\n      if (state.timersCount <= 10) {\n        state.timersCount = state.timersCount + 1\n      }\n    },\n    reset: () => initialState,\n  },\n})\n\nexport const Actions = {\n  ...slice.actions,\n}\n\nexport const Reducer = slice.reducer\n","import { useContainer } from './container'\nexport { Actions, Reducer } from './store'\n\nexport const timers = {\n  service: useContainer,\n}\n","import { useEffect, useRef } from 'react'\nimport { useAppActions } from '@hooks/useAppActions'\nimport { useAppSelector } from '@hooks/useAppSelector'\n\nexport const useContainer: SC = () => {\n  // Чтение данных из store: Начало\n  const { timersQueue } = useAppSelector(state => state.timers)\n  // Чтение данных из store: Конец\n\n  // Работа с данными из store: Начало\n  const {\n    timers: { removeTimerFromQueue },\n    logs: { addLog },\n  } = useAppActions()\n  // Работа с данными из store: Конец\n\n  // Хранилище для таймера: Начало\n  const timerRef = useRef<NodeJS.Timeout | null>(null)\n  // Хранилище для таймера: Конец\n\n  // Запуск и обработка таймера: Начало\n  useEffect(() => {\n    if (timersQueue.length && !timerRef.current) {\n      // Первый элемент в очереди\n      const firstElement = timersQueue[0]\n      // Преобразование в миллисекунды\n      const delay = firstElement * 1000\n\n      addLog(`Инициализация таймера ${firstElement}`)\n      timerRef.current = setTimeout(() => {\n        addLog(`Срабатывание таймера ${firstElement}`)\n\n        // Удаление таймера из очереди\n        removeTimerFromQueue()\n\n        // Очистка ссылки на таймер\n        timerRef.current = null\n      }, delay)\n    }\n\n    if (!timersQueue.length && timerRef.current) {\n      clearTimeout(timerRef.current)\n      timerRef.current = null\n      addLog('Сброс приложения')\n    }\n  }, [timersQueue.length])\n  // Запуск и обработка таймера: Конец\n\n  useEffect(\n    () => () => {\n      if (timerRef.current) {\n        clearTimeout(timerRef.current)\n      }\n    },\n    []\n  )\n}\n","import { Reducer as logs } from '@services/logs'\nimport { Reducer as timers } from '@services/timers'\n\nexport const reducersList = {\n  // Services: Начало\n  logs,\n  timers,\n  // Services: Конец\n\n  // Widgets: Начало\n  // Widgets: Конец\n}\n","import { configureStore } from '@reduxjs/toolkit'\nimport { combineReducers } from 'redux'\nimport { reducersList } from './reducers'\n\nconst rootReducer = combineReducers(reducersList)\n\nexport const store = configureStore({\n  reducer: rootReducer,\n  middleware: getDefaultMiddleware => getDefaultMiddleware(),\n  devTools: process.env.NODE_ENV !== 'production',\n})\n\nexport type AppStateType = ReturnType<typeof rootReducer>\nexport type AppDispatchType = typeof store.dispatch\n","import { Provider } from 'react-redux'\nimport { store } from '@app/store/store'\n\nexport const ReduxStoreProvider: FC = ({ children }) => (\n  <Provider store={store}>{children}</Provider>\n)\n","import { ReduxStoreProvider } from './ReduxStoreProvider'\n\nexport const Providers: FC = ({ children }) => (\n  <ReduxStoreProvider>{children}</ReduxStoreProvider>\n)\n","import { Flex } from '@npm.piece/ui-kit'\n\nimport React from 'react'\n\nexport const NotFound: FC = React.memo(() => (\n  <Flex middle className=\"h-full w-full\">\n    404\n  </Flex>\n))\n","import { Flex } from '@npm.piece/ui-kit'\nimport React from 'react'\n\ntype OwnPropertyType = {}\n\nexport const Loading: FC<OwnPropertyType> = React.memo(() => {\n  const loading = 'Loading'\n\n  return <Flex>{loading}</Flex>\n})\n","import { Main } from './Main'\n\n// Здесь находятся основные макеты приложения, которые могут быть использованы для разных страниц.\n// Макеты в приложении предназначены для определения общей структуры и стилей страниц, на которых они используются.\n// Они помогают обеспечить единообразие и согласованность между разными страницами, что делает разработку и поддержку приложения более эффективной и структурированной.\nexport const Layouts = {\n  Main,\n}\n","import { Suspense } from 'react'\nimport { Outlet } from 'react-router-dom'\nimport { Loading } from '@components/templates/Loading'\nexport const Main: FC = () => (\n  <div className=\"flex min-h-screen flex-col\">\n    <Suspense fallback={<Loading />}>\n      <Outlet />\n    </Suspense>\n  </div>\n)\n","import { lazy } from 'react'\nimport { Route, Routes } from 'react-router-dom'\nimport { NotFound } from '@components/templates/404'\nimport { Layouts } from '@layouts/index'\n\nconst Main = lazy(() =>\n  import('pages/Main').then(module => ({\n    default: module.Page,\n  }))\n)\n\nexport const AppRouter: FC = () => (\n  <Routes>\n    <Route path=\"/\" element={<Layouts.Main />}>\n      <Route index element={<Main />} />\n    </Route>\n\n    {/* <Route path={RoutesEnum.admin} element={<Layouts.Secondary />}>*/}\n    {/*  <Route index element={<div>1</div>} />*/}\n    {/*  <Route path={Constants.routes.banned} element={<div>2</div>} />*/}\n    {/* </Route>*/}\n\n    <Route path=\"*\" element={<NotFound />} />\n  </Routes>\n)\n","import { ErrorBoundary, ServiceInjector } from '@npm.piece/utils'\nimport { AppRouter } from '@app/router'\nimport { timers } from '@services/timers'\n\nexport const App: FC = () => (\n  <>\n    <ErrorBoundary errorComponent={<h1>error</h1>}>\n      <AppRouter />\n    </ErrorBoundary>\n    <ServiceInjector services={[timers.service]} />\n  </>\n)\n","import { Container } from './container'\n\nexport const App = {\n  Container,\n}\n","import { FC } from 'react'\nimport { BrowserRouter } from 'react-router-dom'\nimport { Providers } from '@app/providers'\nimport { App } from '../ui'\n\nimport '../../../index.css'\n\n// Точка входа для разработки\nexport const Container: FC = props => (\n  <BrowserRouter>\n    <Providers>\n      <App {...props} />\n    </Providers>\n  </BrowserRouter>\n)\n\n// Импорт приложения для Плагина ModuleFederation\nexport const ImportedContainer: FC = props => (\n  <Providers>\n    <App {...props} />\n  </Providers>\n)\n","import { createRoot } from 'react-dom/client'\nimport { App } from '@app/entry'\nimport { reportWebVitals } from './reportWebVitals'\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration'\n\nconst container = document.getElementById('root')\n\nconst root = createRoot(container as HTMLDivElement)\n\nroot.render(<App.Container />)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.unregister()\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\ntype ConfigType = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport const register = (config?: ConfigType) => {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nconst registerValidSW = (swUrl: string, config?: ConfigType) => {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nconst checkValidServiceWorker = (swUrl: string, config?: ConfigType) => {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    })\n}\n\nexport const unregister = () => {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister()\n      })\n      .catch(error => {\n        console.error(error.message)\n      })\n  }\n}\n","import { ReportHandler } from 'web-vitals'\n\nexport const reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry)\n      getFID(onPerfEntry)\n      getFCP(onPerfEntry)\n      getLCP(onPerfEntry)\n      getTTFB(onPerfEntry)\n    })\n  }\n}\n","import { useMemo } from 'react'\nimport { useDispatch } from 'react-redux'\nimport { ActionCreatorsMapObject, bindActionCreators } from 'redux'\nimport { AppDispatchType } from '@app/store/store'\nimport { Actions as logsActions } from '@services/logs/'\nimport { Actions as timersActions } from '@services/timers/'\n\n// useAppActions - этот хук использует useActions для создания объектов действий для различных сервисов.\n// Затем он возвращает объект, содержащий все эти действия, сгруппированные по сервисам, что упрощает их использование\n// в компонентах. Этот хук может быть расширен для включения дополнительных действий из сервисов и виджетов.\n// Хук использует useMemo для оптимизации производительности, что гарантирует, что объекты действий не будут пересозданы.\n\n// Если в будущем вы захотите заменить Redux на другую библиотеку для управления состоянием, например Jotai или Zustand,\n// вам нужно будет изменить реализацию только в этом хуке. После замены реализации на новую библиотеку, все компоненты,\n// которые используют useAppActions, продолжат работать корректно, так как они будут использовать адаптированный\n// хук с новой реализацией.\nexport const useAppActions = () => {\n  const dispatch = useDispatch<AppDispatchType>()\n  const createAction = <T extends ActionCreatorsMapObject>(actions: T) =>\n    bindActionCreators(actions, dispatch)\n\n  return useMemo(\n    () => ({\n      // insert actions here\n      logs: createAction(logsActions),\n      timers: createAction(timersActions),\n    }),\n    []\n  )\n}\n","import { TypedUseSelectorHook, useSelector } from 'react-redux'\nimport { AppStateType } from '@app/store/store'\n\n// Хук useAppSelector является типизированным адаптером для стандартного хука useSelector из библиотеки react-redux.\n// Этот хук обеспечивает привязку к типу состояния вашего приложения, указанному в AppStateType, что облегчает работу\n// с типами TypeScript и упрощает извлечение данных из хранилища Redux.\n//\n// Если в будущем вы захотите заменить Redux на другую библиотеку для управления состоянием, например MobX или Zustand,\n// вам нужно будет изменить реализацию только в этом хуке.\n// После замены реализации на новую библиотеку, все компоненты, которые используют useAppSelector, продолжат работать корректно,\n// так как они будут использовать адаптированный хук с новой реализацией.\n//\n// useAppSelector служит удобным адаптером между вашими компонентами и библиотекой управления состоянием,\n// обеспечивая гибкость и абстракцию от конкретной реализации.\nexport const useAppSelector: TypedUseSelectorHook<AppStateType> = useSelector\n"],"names":["Constants","app","name","json","concat","initialState","logs","slice","createSlice","reducers","addLog","state","action","date","Date","dateToString","getHours","getMinutes","getSeconds","getMilliseconds","push","text","payload","length","shift","reset","Actions","actions","Reducer","reducer","timersCount","timersQueue","addTimerToQueue","removeTimerFromQueue","addTimer","timers","service","useContainer","useAppSelector","useAppActions","timerRef","useRef","useEffect","current","firstElement","delay","setTimeout","clearTimeout","reducersList","rootReducer","combineReducers","store","configureStore","middleware","getDefaultMiddleware","devTools","process","ReduxStoreProvider","_ref","children","_jsx","Provider","Providers","NotFound","React","Flex","middle","className","Loading","Layouts","Main","Suspense","fallback","Outlet","lazy","then","module","default","Page","AppRouter","_jsxs","Routes","Route","path","element","index","App","_Fragment","ErrorBoundary","errorComponent","ServiceInjector","services","props","BrowserRouter","container","Boolean","window","location","hostname","match","document","getElementById","onPerfEntry","createRoot","render","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message","Function","getCLS","getFID","getFCP","getLCP","getTTFB","dispatch","useDispatch","createAction","bindActionCreators","useMemo","logsActions","timersActions","useSelector"],"sourceRoot":""}